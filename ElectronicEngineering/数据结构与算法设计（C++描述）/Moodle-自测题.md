# 数据结构与算法设计（C++描述）-自测题

> 2021年3月4日起。

## C++01-课后练习1

> 2021年3月4日。

面向对象程序设计将数据与【】放在一起，作为一个相互依存、不可分割的整体来处理。

选择一项：

- [✗]数据隐藏

- [✗]信息

- [✓]对数据的操作

- [✗]数据抽象

---

下列关于 C ＋＋的类和对象的描述中，不正确的有【】。

选择一项：

- [✓]一个类只能有一个对象

- [✗]对象是类的一个实例

- [✗]任何一个对象只能属于一个具体的类

- [✗]类与对象的关系和数据类型与变量的关系相似

---

在类的定义体外定义成员函数时，需要在函数名前加上【】。

选择一项：

- [✗]类名

- [✓]类名及作用域运算符

- [✗]类对象

- [✗]作用域运算符

---

类中定义的成员默认为【】访问属性。

选择一项：

- [✗]protected

- [✗]friend

- [✓]private

- [✗]public

---

有关类的说法不正确的是【】。

选择一项：

- [✗]对象是类的实例化

- [✗]类是一种用户自定义的数据类型

- [✗]在类中，如果不做特别说明，所有的数据成员均为私有类型

- [✓]在类中，如果不做特别说明，所有的成员函数均为公有类型

---

下列关于类和对象的叙述中，正确的是

选择一项：

- [✗]成员函数只能在类体外进行定义

- [✗]类成员的缺省访问权限是保护的

- [✓]类定义中包括数据成员和成员函数的声明

- [✗]数据成员必须被声明为私有的

---

假定classA为一个类，f()为该类公有的成员函数，x为该类的一个对象，则访问x对象中的成员函数f()的格式为【】。

选择一项：

- [✗]x.f

- [✗]x->f

- [✓]x.f()

- [✗]x->f()

---

要求通过函数来实现一种不太复杂的功能，并且要求加快执行速度，选用【】。

选择一项：

- [✗]重载函数

- [✗]嵌套调用

- [✗]递归调用

- [✓]内联函数

---

【】功能是对对象进行初始化

选择一项：

- [✓]构造函数

- [✗]静态成员函数

- [✗]析构函数

- [✗]数据成员

---

假定一个类的构造函数为“A(int aa=1, int bb=2){a=aa;b=bb;}”，则执行“A x(9)”语句后，x.a和x.b的值分别为【】。

选择一项：

- [✗]1和2
- [✗]9和1
- [✓]9和2
- [✗]1和9

##  C++02-课后练习2

> 2021年3月11日。

假定一个类是 Student ，那么该类的拷贝构造函数是【】。

选择一项：

- [✗]Student（Student　s）
- [✓]Student（Student　&s）
- [✗]Student　*（Student　s）
- [✗]Student（Student　*s）

---

类的构造函数时在定义该类的一个【】时被自动调用执行的。                

选择一项：

- [✗]数据成员
- [✗]友元函数
- [✓]对象
- [✗]成员函数

---

下列关于析构函数的说法中，不正确的是【】。

选择一项：

- [✓]析构函数的名字只是类名
- [✗]析构函数绝对不能有参数
- [✗]析构函数无函数类型
- [✗]类中只有一个析构函数

---

下列关于类和对象的叙述中，正确的是

选择一项：

- [✗]成员函数只能在类体外进行定义
- [✓]类定义中包括数据成员和成员函数的声明
- [✗]类成员的缺省访问权限是保护的
- [✗]数据成员必须被声明为私有的

---

关于成员函数特征的下述描述中，不正确的是【】。

选择一项：

- [✗]成员函数可以设置参数的默认值
- [✗]成员函数可以重载
- [✗]成员函数可以是私有的
- [✓]成员函数一定是内联函数

---

类的实例化是指【】。

选择一项：

- [✗]定义类
- [✗]指明具体类
- [✗]调用类的成员
- [✓]创建类的对象

---

假定classA为一个类，a为该类公有的数据成员，px为指向该类对象的一个指针，则访问px所指对象中的数据成员a的格式为【】。

选择一项：

- [✗]`px.a`
- [✗]`px[a]`
- [✗]`px(a)`
- [✓]`px->a`

---

对于下面定义的类MyClass，在主函数中将对象成员n的值修改为50的语句是【】。

```c++
class MyClass
{
public:
  Myclass(int x){n=x;}
  void SetNum(int nl){n=nl;}
private:
  int n;
};
int main()
{
  MyClass *ptr=new MyClass(45);
                     
  return 0;
}
 
```

选择一项：

- [✗]`ptr->n=50;`
- [✓]`ptr->SetNum(50);`
- [✗]`MyClass(50);`
- [✗]`SetNum(50);`

---

Sample是一个类，执行语句Sample a[2]，*p=new Sample;后，调用Sample类的构造函数的次数是【】。

选择一项：

- [✓]3
- [✗]4
- [✗]2
- [✗]1

---

假设AB为一个类，px为指向该类的一个含有n个对象的动态数组的指针，则执行语句"delete []px;"时，共调用该类的析构函数的次数为【】。

选择一项：

- [✗]0
- [✓]`n`
- [✗]1
- [✗]`n+1`

## C++03-课后练习3

> 2021年3月18日。

关于友元的描述中，【】是错误的。

选择一项：

- [✓]若友元函数在类体内定义，则它就是该类的成员函数
- [✗]友元类中的所有成员函数都是友元函数
- [✗]友元函数破坏类的封装性，使用时应少用
- [✗]友元函数可直接访问类中的私有成员

---

已知类A是类B的友元，类B是类C的友元，则【】。

选择一项：

- [✗]类C的成员函数可以访问类B的对象的任何成员
- [✗]类C一定是类A的友元
- [✗]类A一定是类C的友元
- [✓]类Ａ的成员函数可以访问类Ｂ的对象的任何成员

---

下列关于运算符重载的叙述中，正确的是【】。

选择一项：

- [✗]重载一个二元运算符时，必须声明两个形参
- [✗]通过运算符重载，可以定义新的运算符
- [✓]有的运算符只能作为成员函数重载
- [✗]若重载运算符+，则相应的运算符函数名是+

---

执行语句"person p1=p2;”将调用p1的。

选择一项：

- [✓]拷贝构造函数
- [✗]赋值运算符重载函数
- [✗]析构函数
- [✗]构造函数

---

下列函数中，【】不能重载。

选择一项：

- [✗]构造函数
- [✗]成员函数
- [✗]非成员函数
- [✓]析构函数

---

重载函数在调用时选择的依据中，错误的是【】。

选择一项：

- [✗]函数名字
- [✗]参数个数
- [✗]参数的类型
- [✓]函数的类型

---

在下列各类函数中，【】不是类的成员函数。

选择一项：

- [✓]友元函数
- [✗]构造函数
- [✗]拷贝初始化构造函数
- [✗]析构函数

---

变量的引用就是变量的【】。

选择一项：

- [✗]值
- [✗]类型
- [✓]别名
- [✗]内存地址

---

在一个类中可以对一个操作符进行【】重载。

选择一项：

- [✓]多种
- [✗]3种以下
- [✗]2种以下
- [✗]1种

---

下面程序中对一维坐标点类Point进行运算符重载：

```c++
#include <iostream>   
using namespace std;
class Point
{
 public:
   Point (int val) {x=val;}
   Point & operator ++() {x++;return *this;}
   Point operator ++(int){Point old=*this;++(*this);return old;}
  int GetX() const {return x;}
private:
   int x;
};
int main()
{
  Point a(10);
  cout<<(++a).GetX();
  cout<<(a++).GetX();
  return 0;
}
```

编译和运行情况是【】。

选择一项：

- [✓]1111
- [✗]1112
- [✗]1011
- [✗]编译有错

## C++04-课后练习4

> 2021年3月25日。

在C++中，通过【】的机制可以扩充和完善旧的程序设计以适应新的需要。

选择一项：

- [✗]多态
- [✗]重载
- [✓]继承
- [✗]封装

---

在多继承中，公有派生和私有派生对于基类成员在派生类中的可访问性与单继承的规则【】。

选择一项：

- [✗]完全不同
- [✓]完全相同
- [✗]部分相同，部分不同
- [✗]以上都不对

---

下列对派生类的描述中，【】是错误的。 

选择一项：

- [✓]派生类中继承的基类成员的访问权限到派生类保持不变
- [✗]派生类至少有一个基类
- [✗]一个派生类可以作另一个派生类的基类
- [✗]派生类的成员除了它自己的成员外，还包含了它的基类的成员

---

在公有派生情况下，有关派生类对象和基类对象的关系，不正确的叙述是【】。

选择一项：

- [✗]派生类的对象可以赋给基类的对象
- [✓]派生类的对象可以直接访问基类中的成员
- [✗]派生类的对象的地址可以赋给指向基类的指针
- [✗]派生类的对象可以初始化基类的引用

---

派生类的成员函数可以直接访问基类的【】成员。

选择一项：

- [✗]所有
- [✗]私有和保护
- [✗]私有
- [✓]公有和保护

---

当保护继承时，基类的【】在派生类中成为保护成员，在类作用域外不能够通过派生类的对象来直接访问该成员。

选择一项：

- [✓]公有成员和保护成员
- [✗]任何成员
- [✗]保护成员
- [✗]私有成员

---

派生类的对象对其基类中【】可直接访问。

选择一项：

- [✗]私有继承的公有成员
- [✗]公有继承的私有成员
- [✗]公有继承的保护成员
- [✓]公有继承的公有成员

---

撤销包含有类对象成员的派生类对象时，自动调用析构函数的执行顺序依次为【】的析构函数。

选择一项：

- [✗]基类、对象成员所属类、自己所属类
- [✗]对象成员所属类、基类、自己所属类
- [✓]自己所属类、对象成员所属类、基类
- [✗]基类、自己所属类、对象成员所属类

---

C++中的虚基类机制可以保证【】。

选择一项：

- [✗]限定基类只通过一条路径派生出派生类
- [✓]当一个类多次间接从基类派生以后，其基类只被一次继承。
- [✗]当一个类多次间接从基类派生以后，派生类对象能保留多份间接基类的成员
- [✗]允许基类通过多条路径派生出派生类，派生类也就能多次继承该基类

---

设置虚基类的目的是【】。

选择一项：

- [✗]减少目标代码
- [✗]提高运行效率
- [✗]简化程序
- [✓]消除二义性

## C++05-课后练习5

> 2021年4月1日。

对虚函数的调用【】。

选择一项：

- [✗]一定使用动态联编
- [✗]一定使用静态联编
- [✗]必须使用动态联编
- [✓]不一定使用动态联编

---

在 C ＋＋中用来实现运行时多态性的是【】。

选择一项：

- [✗]重载函数
- [✓]虚函数
- [✗]析构函数
- [✗]静态成员

---

如果一个类至少有一个纯虚函数，那么就称该类为【】。

选择一项：

- [✗]派生类
- [✗]以上都不对
- [✓]抽象类
- [✗]虚基类

---

下列叙述中，不正确的是【】。

选择一项：

- [✗]纯虚函数不能定义其实现部分
- [✗]含纯虚函数的类为抽象类
- [✓]抽象类不能作为派生类的基类
- [✗]不能直接由抽象类建立对象

---

【】是一个在基类中说明的虚函数，它在该基类中没有定义，但其派生类可定义自己的版本。

选择一项：

- [✓]纯虚函数
- [✗]虚构造函数
- [✗]静态成员函数
- [✗]虚析构函数

---

在C++中，要实现动态联编，必须使用【】调用虚函数。

选择一项：

- [✗]类名
- [✓]基类指针
- [✗]对象名
- [✗]派生类指针

---

下面的函数原型声明中，【】声明了fun为纯虚函数。

选择一项：

- [✗]`virtual void fun(){};`
- [✓]`virtual void fun()=0;`
- [✗]`virtual void fun();`
- [✗]`void fun()=0;`

---

多态性提高了系统的【】。

选择一项：

- [✓]包括以上三项
- [✗]可维护性
- [✗]一致性
- [✗]灵活性

---

假设A为抽象类，下列声明【】是正确的。

选择一项：

- [✗]`int fun(A);`
- [✗]`A fun(int);`
- [✓]`A *p;`
- [✗]`A obj;`

---

当一个类的某个函数被说明为virtual时，该函数在该类的所有派生类中【】。

选择一项：

- [✓]都是虚函数
- [✗]只有被重新说明为virtual时才是虚函数
- [✗]都不是虚函数
- [✗]只有被重新说明时才是虚函数

## C++06-课后练习6

> 2021年4月10日。
>
> 还没学到模板呢……

关于模板描述错误的是【】。　　

选择一项：

- [✗]模板把数据类型作为设计参数，成为泛型程序设计
- [✓]类模板和模板类是同一概念
- [✗]是不同的概念
- [✗]模板参数除了模板类型参数外，还可以有非类型参数

---

类模板的实例化【】。

选择一项：

- [✗]在运行时进行
- [✗]属于动态联编
- [✓]在编译时进行
- [✗]在连接时进行

---

【】使一个函数可以定义成对不同数据类型完成相同操作。

选择一项：

- [✗]递归函数
- [✗]模板函数
- [✓]函数模板
- [✗]重载函数

---

下列有关函数模板和模板函数说法中，错误的是【】。

选择一项：

- [✗]后才能执行。
- [✗]是实实在在的函数，它由编译系统在遇到具体函数调用时所生成，并调用执行。
- [✓]当函数模板和一般函数同名时，系统先去匹配函数模板，将其实例化后进行调用。
- [✗]函数模板只是对函数的描述，编译器不为其产生任何执行代码，所以它不是一个实实在在的函数。

---

下面函数模板的定义中，有【】处错误。

```c++
template<class T1, T2>
T2 f1(T1 a, b)
{
    return (a>b)?(a):(b);
} 
```

选择一项：

- [✗]1
- [✓]2
- [✗]3
- [✗]4

---

一个【】允许用户为类定义一种模式，使得类中的某些数据成员及某些成员函数的返回值能取任意类型。

选择一项：

- [✗]模板类
- [✗]函数模板
- [✓]类模板
- [✗]模板函数

---

类模板的模板参数【】。

选择一项：

- [✗]只可以作为数据成员的类型
- [✗]只可以作为成员的返回类型
- [✗]只可以作为成员函数的参数类型
- [✓]三项均可以

---

下面对模板的声明中，正确的是【】。

选择一项：

- [✗]`template<T>`
- [✗]`template<class T1, T2>`
- [✓]`template<class T1, class T2>`
- [✗]`template<class T1;class T2>`

---

函数模板

```c++
template <class T>
T add(T x, T y) {
    return x+y;
}
```

下列对add函数的调用不正确的是【】。

选择一项：

- [✗]`add(1.0,2.0)`
- [✗]`add<int>(1,2)`
- [✓]`add(1.0,2)`
- [✗]`add<>(1,2)`

---

设有函数模板

```c++
template<class Q>
Q Sum(Q x, Q y)
{
    return (x)+(f);
}
```

则下列语句对该函数模板错误的使用是【】。

选择一项：

- [✗]`Sum(5.0,6.7);`
- [✓]`Sum("AB","CD");`
- [✗]`Sum(16.3f,23.0f);`
- [✗]`Sum(10,2);`

## DS01-简单练习01

> 2021年4月29日。

研究数据结构就是研究（  ）

选择一项：

- [✗]数据的存储结构
- [✓]数据的逻辑结构、存储结构及其数据在运算上的实现
- [✗]数据的逻辑结构

---

数据的（ ）包括集合、栈、树和图结构4种基本类型。

选择一项：

- [✗]算法描述
- [✗]存储结构
- [✓]逻辑结构
- [✗]基本运算

---

与数据元素本身的形式、内容、相对位置、个数无关的是数据的（ ）

选择一项：

- [✗]运算实现
- [✗]存储结构
- [✗]存储实现
- [✓]逻辑结构

---

数据的（ ）包括查找、插入、删除、更新、排序等操作类型。

选择一项：

- [✗]逻辑结构
- [✗]算法描述
- [✗]存储结构
- [✓]基本运算

---

计算机中的算法是指解决某个问题的有限运算序列，它必须具备输入、输出、（ ）等5个特性。

选择一项：

- [✗]易读性、稳定性和确定性
- [✗]可行性、可移植性和可扩充性
- [✗]确定性、有穷性和稳定性
- [✓]可行性、有穷性和确定性

## DS02-简单练习02

> 2021年4月29日。

链表不具备的特点是【】。

选择一项：

- [✗]不必事先估计存储空间。
- [✓]可随机访问任一结点。
- [✗]插入删除不需要移动元素。
- [✗]所需空间与其长度成正比。

---

带头结点的单链表 head 为空的判定条件是

选择一项：

- [✓]`head->next==NULL`
- [✗]`head==NULL`
- [✗]`head->next==head`
- [✗]`head!==NULL`

---

如果最常用的操作是取第 i 个结点及其前驱，则采用 存储方式最节省时间。

选择一项：

- [✗]单循环链表
- [✗]单链表
- [✗]双链表
- [✓]顺序表

---

线性表是具有 n 个【】的有限序列（ n>0 ）。

选择一项：

- [✗]表元素
- [✗]数据项
- [✓]数据元素
- [✗]元素

---

需要分配较大空间，插入和删除不需要移动元素的线性表，其存储结构是【】。 

选择一项：

- [✓]静态链表
- [✗]线性链表
- [✗]顺序存储结构
- [✗]单链表

## DS03_DS04-简单练习0304

> 2021年5月6日。

栈和队列的共同点是

选择一项：

- [✗]都是先进先出
- [✗]没有共同点
- [✗]都有是先进后出
- [✓]只允许在端点处插入和删除元素

---

循环队列Q（最多元素为MaxSize），用front和rear分别表示队头和队尾，则循环队列为满的条件是

选择一项：

- [✗]`Q.rear==Q.front+1`
- [✗]`Q.rear+1==Q.front`
- [✓]`(Q.rear+1)%MaxSize==Q.front`
- [✗]`Q.rear==Q.front`

---

一个栈的进栈序列是 a ， b ， c ， d ， e ，则栈的不可能输出的序列是

选择一项：

- [✓]`dceab`
- [✗]`edcba`
- [✗]`abcde`
- [✗]`decba`

---

判断一个顺序栈 st （最多元素为 MaxSize ）为空的条件是

选择一项：

- [✗]`st->top!=-1`
- [✗]`st->top!=MaxSize-1`
- [✓]`st->top==-1`
- [✗]`st->top!=MaxSize-1`

---

判断一个顺序栈 st （最多元素为 MaxSize ）为栈满的条件是

选择一项：

- [✓]`st->top==MaxSize-1`
- [✗]`st->top!=MaxSize-1`
- [✗]`st->top!=-1`
- [✗]`st->top==-1`

---

向一个栈顶指针为 hs 的链栈中插入一个 s 所指结点时，则执行【】。

选择一项：

- [✗]`s->next=hs; hs=hs->next`
- [✓]`s->next=hs; hs=s;`
- [✗]`hs->next=s`
- [✗]`s->next=hs->next; hs->next=s;`

---

一个队列的入队序列是 1 ， 2 ， 3 ， 4 ，则队列的输出序列是

选择一项：

- [✗]4，3，2，1
- [✗]3，2，4，1
- [✓]1，2，3，4
- [✗]1，4，3，2

---

若已知一个栈的进栈序列是 1 ， 2 ， 3 ， … ， n ，其输出序列为 p1 ， p2 ， p3 ， … ， pn ，若 p1=3 ，则 p2【】。 

选择一项：

- [✗]可能是1
- [✗]一定是1
- [✓]可能是2
- [✗]一定不是2

---

设栈的输入序列是1，2，3，4，则【】不可能是其出栈序列

选择一项：

- [✓]4，3，1，2
- [✗]1，2，4，3
- [✗]2，1，3，4
- [✗]1，4，3，2

---

队列通常采用的两种存储结构是【】。

选择一项：

- [✗]线性存储结构和非线性存储结构
- [✗]单链表和循环链表
- [✗]散列方式和索引方式
- [✓]顺序存储结构和链表存储结构

## DS05_DS06-简单练习05

> 2021年5月21日。

树最适合用来表示

选择一项：

- [✗]有序数据元素
- [✓]元素之间具有分支层次关系的数据
- [✗]无序数据元素
- [✗]元素之间无联系的数据

---

高度为 4 （从0开始）的二叉树至多有  个结点的。

选择一项：

- [✗]32
- [✗]16
- [✓]31
- [✗]10

---

在一非空二叉树的中序遍历序列中，根结点的右边

选择一项：

- [✗]只有左子树上的部分结点
- [✓]只有右子树上的所有结点
- [✗]只有右子树上的部分结点
- [✗]只有左子树上的所有结点

---

 任何一棵二叉树的叶子结点在先序、中序和后序遍历序列中的相对次序  。 

选择一项：

- [✓]不发生改变
- [✗]发生改变
- [✗]不能确定
- [✗]以上都不对

---

对一个满二叉树， m 个树叶， n 个结点，深度为 h（从0开始） ，则  。

选择一项：

- [✗]`m=h-1`
- [✓]n=2^（h+1）-1
- [✗]`n=h+m`
- [✗]`h+m=2n`

---

 设 n 、 m 为一棵二叉树上海两个结点，在中序遍历时， n 在 m 前的条件是  。 

选择一项：

- [✗]n在m右方
- [✗]n是m子孙
- [✗]n是m祖先
- [✓]n在m左方

---

 二叉树的先序遍历中，任意一个结点均处在其孩子结点的前面，这种说法  。 

选择一项：

- [✓]对
- [✗]错

---

设高度为h（从0开始）的二叉树上只有度为0和度为2的结点，则此类二叉树中所包含的结点数至少为2^h

选择一项：

- [✗]对
- [✓]错

## DS05_DS06-简单练习06

> 2021年6月5日。

在一个无向图中，所有顶点的度数之和等于所有边数的【】倍。

选择一项：

- [✓]2
- [✗]`1/2`
- [✗]1
- [✗]4

---

以下说法中不正确的是【】。

选择一项：

- [✗]有向图中的极大连通子图称为强连通分量
- [✗]图的深度优先搜索中一般要采用栈来暂存刚访问过的顶点
- [✗]无向图中的极大连通子图称为连通分量
- [✓]有向图的邻接表和逆邻接表中表结点的个数不一定相等。

---

在一个有向图中，所有顶点的入度之和等于所有顶点的出度之和的【】倍。

选择一项：

- [✗]`1/2`
- [✗]2
- [✗]4
- [✓]1

---

具有 4 个顶点的无向完全图有【】条边。

选择一项：

- [✗]12
- [✗]20
- [✓]6
- [✗]16

---

在一个具有 n 个顶点的无向图中，要连通全部顶点至少需要【】条边。

选择一项：

- [✗]`n`
- [✗]`n/2`
- [✓]`n-1`
- [✗]`n+1`

---

对于一个具有 n 个顶点的无向图，若采用邻接矩阵表示，则该矩阵大小是【】。

选择一项：

- [✗]`n-1`
- [✓]`n^2`
- [✗]（n-1）^2
- [✗]`n`

---

对某个无向图的邻接矩阵来说，【】。

选择一项：

- [✗]矩阵中的非零元素个数等于图中的边数
- [✓]第i行上的非零元素个数和第i列的非零元素个数一定相等
- [✗]第i行上，第i列上非零元素总数等于顶点vi的度数
- [✗]矩阵中非全零行的行数等于图中的顶点数

---

采用邻接表存储的图的深度优先遍历算法类似于二叉树的【】。

选择一项：

- [✓]先序遍历
- [✗]中序遍历
- [✗]按层遍历
- [✗]后序遍历

---

 采用邻接表存储的图的广度优先遍历算法类似于二叉树的【】。 

选择一项：

- [✗]先序遍历
- [✗]后序遍历
- [✗]中序遍历
- [✓]按层遍历

---

 任何一个无向连通图的最小生成树【】。 

选择一项：

- [✓]有一棵或多棵
- [✗]只有一棵
- [✗]一定有多棵
- [✗]可能不存在

# 后备箱

> 源自“C语言程序设计Moodle-自测题”。

首先复制以下代码（可<kbd>Ctrl</kbd>+<kbd>A</kbd>, <kbd>Ctrl</kbd>+<kbd>C</kbd>）到控制台，然后“粘贴为纯文本”（<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>V</kbd>）至相应位置。

> 以下代码待改进：它有时会把本来没有程序的题目当成程序选择题。

```javascript
let questions = [];
for (const q of document.querySelectorAll('div[id^=question] > .content > .formulation')) {
    let question = {
        'text': '',
        'prompt': '',
        'answers': []
    };

    // 题干
    let qtext = q.querySelector('div.qtext');
    if (qtext.childElementCount == 0) {
        question['text'] = qtext.textContent.replace(/\s{3,}/, "【】");
    }
    else {
        qtext.childNodes.forEach(
            function (p, index) {
                if (index == 1) {
                    question['code'] = [];
                }

                if (index == 0) {
                    // console.log(p);
                    question['text'] = p.textContent.replace(/\s{3,}/, "【】");
                }
                else if (p.nodeName != '#text') {
                    question['code'].push(p.textContent.replace(/^s/g, " "));
                }
            }
        );
    }

    // 一般是“选择一项：”
    question['prompt'] = q.querySelector('div.prompt').textContent;

    // 选项
    for (const a of q.querySelectorAll('div.answer > div')) {
        question['answers'].push([
            a.querySelector("input").checked,
            a.querySelector("label").lastChild.textContent
        ]);
        // label 若不用 lastChild，会带一个 <span>（abcdABCD等）
    }

    questions.push(question);
}

console.table(questions);

function answer_to_markdown(answer) {
    let res = "- ";
    res += answer[0] ? '[✓]' : '[✗]';
    if (!/^\d+$/.test(answer[1]) && /^[\u0000-\u0080]+$/.test(answer[1])) {
        res += "`" + answer[1] + "`";
    }
    else {
        res += answer[1];
    }
    return res;
}

function question_to_markdown(question, language = 'c++', newline = '\n\n') {
    let paragraphs = [question['text']];
    if (question.hasOwnProperty('code')) {
        paragraphs.push('```' + language + '\n' + question['code'].join('\n') + '\n```');
    }
    paragraphs.push(question['prompt']);
    paragraphs.push(question['answers'].map(answer_to_markdown).join('\n'));

    return paragraphs.join(newline);
}

function questions_to_markdown(questions, newline = '\n\n') {
    // 若 map 里直接写 question_to_markdown，传给它的参数除了 currentValue，还会有 index 等，导致 newline 不是默认值，结果里会出现一堆“[object]”。
    return questions.map(x => question_to_markdown(x)).join(newline + '---' + newline);
}

copy(questions_to_markdown(questions));

```

